import * as Config from './config';
import ClassBuffer from './class-buffer';
import Image from './image';
import Tile, { TileAggregation } from './tile';
import Color from './color';
import * as Scale from './scale';
import Mask from './mask';
export default class Interpreter {
    config: Config.Config;
    debug: boolean;
    description?: string;
    width: number;
    height: number;
    n: number;
    schema: Config.SchemaSpec;
    blurredBuffers: ClassBuffer[];
    classBuffers: ClassBuffer[];
    image: Image[];
    tiles: Tile[];
    tileAggregation: TileAggregation;
    strokeCanvas: boolean;
    backgroundStroke: string;
    fillCanvas: boolean;
    background?: string;
    bufferNames: string[];
    colors0: Color[];
    colors1: Color[];
    rebin?: Config.RebinSpec;
    assemble: (buffers: ClassBuffer[], values: number[]) => Color;
    masks: Mask[];
    maskStroke?: string;
    contour: Config.ContourSpec;
    geo: Config.GeoSpec;
    legend: Config.LegendSpec | false;
    scale: Scale.ScaleTrait;
    xdomain: Config.NumPair;
    ydomain: Config.NumPair;
    stroke?: Config.StrokeSpec;
    axis?: Config.AxisSpec;
    d3scale: string;
    d3base: number;
    d3exponent: number;
    log(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    constructor(config: Config.Config, debug?: boolean);
    interpret(): void;
    private computePreprocess();
    private computeStyle();
    private computeRebin();
    private computeAssembly(context?);
    private setup(canvas, width, height);
    private renderMap(canvas, wrapper, width, height);
    render(id: string | HTMLDivElement, forcedWidth?: number, forcedHeight?: number): void;
    private renderAxis(map, native, forcedWidth?, forcedHeight?);
    private renderStroke(canvas);
    pickDomains(x: number, y: number): [number, number] | null;
    pickValues(x: number, y: number): number[];
    pickTile(x: number, y: number): Tile | null;
}
